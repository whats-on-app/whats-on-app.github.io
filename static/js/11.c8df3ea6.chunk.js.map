{"version":3,"sources":["../node_modules/decode-uri-component/index.js","../node_modules/split-on-first/index.js","../node_modules/filter-obj/index.js","../node_modules/query-string/base.js","../node_modules/query-string/index.js","../node_modules/react-intersection-observer/react-intersection-observer.m.js"],"names":["singleMatcher","RegExp","multiMatcher","decodeComponents","components","split","decodeURIComponent","join","length","left","slice","right","Array","prototype","concat","call","decode","input","tokens","match","i","decodeUriComponent","encodedURI","TypeError","replaceMap","%FE%FF","%FF%FE","exec","result","entries","Object","keys","key","replace","customDecodeURIComponent","splitOnFirst","string","separator","separatorIndex","indexOf","includeKeys","object","predicate","isArray","descriptor","getOwnPropertyDescriptor","enumerable","defineProperty","Reflect","ownKeys","isNullOrUndefined","value","undefined","strictUriEncode","encodeURIComponent","x","charCodeAt","toString","toUpperCase","encodeFragmentIdentifier","Symbol","validateArrayFormatSeparator","encode","options","strict","base_decode","removeHash","hashStart","parseValue","parseNumbers","Number","isNaN","trim","parseBooleans","toLowerCase","extract","queryStart","parse","query","sort","arrayFormat","arrayFormatSeparator","formatter","accumulator","includes","isEncodedArray","newValue","map","item","test","arrayValue","flat","parserForArrayFormat","returnValue","create","parameter","parameter_","key2","value2","reduce","Boolean","keysSorter","a","b","stringify","shouldFilter","skipNull","skipEmptyString","index","keyValueSep","encoderForArrayFormat","objectCopy","filter","parseUrl","url","_url_$split$","_url_","_url_$split","url_","hash","parseFragmentIdentifier","fragmentIdentifier","stringifyUrl","[object Object]","queryString","getHash","urlObjectForFragmentEncode","URL","pick","exclude","__webpack_exports__","__webpack_require__","d","useInView","react__WEBPACK_IMPORTED_MODULE_0__","_extends","assign","target","arguments","source","hasOwnProperty","apply","this","_setPrototypeOf","o","p","setPrototypeOf","__proto__","observerMap","Map","RootIds","WeakMap","rootId","unsupportedValue","optionsToId","root","has","get","set","observe","element","callback","fallbackInView","window","IntersectionObserver","bounds","getBoundingClientRect","isIntersecting","intersectionRatio","threshold","time","boundingClientRect","intersectionRect","rootBounds","_createObserver","id","instance","thresholds","elements","observer","forEach","entry","_elements$get","inView","some","trackVisibility","isVisible","createObserver","callbacks","push","splice","unobserve","size","disconnect","_excluded","isPlainChildren","props","children","InView","_React$Component","subClass","superClass","_this","node","_unobserveCb","handleNode","triggerOnce","skip","setState","initialInView","observeNode","handleChange","onChange","state","constructor","_proto","componentDidUpdate","prevProps","rootMargin","delay","componentWillUnmount","_this$props","render","_this$state","ref","_this$props2","as","excluded","sourceKeys","_objectWithoutPropertiesLoose","_temp","_ref","_React$useState","setRef","current","displayName","defaultProps"],"mappings":"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","file":"static/js/11.c8df3ea6.chunk.js","sourcesContent":["const token = '%[a-f0-9]{2}';\nconst singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');\nconst multiMatcher = new RegExp('(' + token + ')+', 'gi');\nfunction decodeComponents(components, split) {\n  try {\n    // Try to decode the entire string first\n    return [decodeURIComponent(components.join(''))];\n  } catch {\n    // Do nothing\n  }\n  if (components.length === 1) {\n    return components;\n  }\n  split = split || 1;\n\n  // Split the array in 2 parts\n  const left = components.slice(0, split);\n  const right = components.slice(split);\n  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input);\n  } catch {\n    let tokens = input.match(singleMatcher) || [];\n    for (let i = 1; i < tokens.length; i++) {\n      input = decodeComponents(tokens, i).join('');\n      tokens = input.match(singleMatcher) || [];\n    }\n    return input;\n  }\n}\nfunction customDecodeURIComponent(input) {\n  // Keep track of all the replacements and prefill the map with the `BOM`\n  const replaceMap = {\n    '%FE%FF': '\\uFFFD\\uFFFD',\n    '%FF%FE': '\\uFFFD\\uFFFD'\n  };\n  let match = multiMatcher.exec(input);\n  while (match) {\n    try {\n      // Decode as big chunks as possible\n      replaceMap[match[0]] = decodeURIComponent(match[0]);\n    } catch {\n      const result = decode(match[0]);\n      if (result !== match[0]) {\n        replaceMap[match[0]] = result;\n      }\n    }\n    match = multiMatcher.exec(input);\n  }\n\n  // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n  replaceMap['%C2'] = '\\uFFFD';\n  const entries = Object.keys(replaceMap);\n  for (const key of entries) {\n    // Replace all decoded components\n    input = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n  }\n  return input;\n}\nexport default function decodeUriComponent(encodedURI) {\n  if (typeof encodedURI !== 'string') {\n    throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n  }\n  try {\n    // Try the built in decoder first\n    return decodeURIComponent(encodedURI);\n  } catch {\n    // Fallback to a more advanced decoder\n    return customDecodeURIComponent(encodedURI);\n  }\n}","export default function splitOnFirst(string, separator) {\n  if (!(typeof string === 'string' && typeof separator === 'string')) {\n    throw new TypeError('Expected the arguments to be of type `string`');\n  }\n  if (string === '' || separator === '') {\n    return [];\n  }\n  const separatorIndex = string.indexOf(separator);\n  if (separatorIndex === -1) {\n    return [];\n  }\n  return [string.slice(0, separatorIndex), string.slice(separatorIndex + separator.length)];\n}","export function includeKeys(object, predicate) {\n  const result = {};\n  if (Array.isArray(predicate)) {\n    for (const key of predicate) {\n      const descriptor = Object.getOwnPropertyDescriptor(object, key);\n      if (descriptor === null || descriptor === void 0 ? void 0 : descriptor.enumerable) {\n        Object.defineProperty(result, key, descriptor);\n      }\n    }\n  } else {\n    // `Reflect.ownKeys()` is required to retrieve symbol properties\n    for (const key of Reflect.ownKeys(object)) {\n      const descriptor = Object.getOwnPropertyDescriptor(object, key);\n      if (descriptor.enumerable) {\n        const value = object[key];\n        if (predicate(key, value, object)) {\n          Object.defineProperty(result, key, descriptor);\n        }\n      }\n    }\n  }\n  return result;\n}\nexport function excludeKeys(object, predicate) {\n  if (Array.isArray(predicate)) {\n    const set = new Set(predicate);\n    return includeKeys(object, key => !set.has(key));\n  }\n  return includeKeys(object, (key, value, object) => !predicate(key, value, object));\n}","import decodeComponent from 'decode-uri-component';\nimport splitOnFirst from 'split-on-first';\nimport { includeKeys } from 'filter-obj';\nconst isNullOrUndefined = value => value === null || value === undefined;\n\n// eslint-disable-next-line unicorn/prefer-code-point\nconst strictUriEncode = string => encodeURIComponent(string).replace(/[!'()*]/g, x => \"%\".concat(x.charCodeAt(0).toString(16).toUpperCase()));\nconst encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');\nfunction encoderForArrayFormat(options) {\n  switch (options.arrayFormat) {\n    case 'index':\n      {\n        return key => (result, value) => {\n          const index = result.length;\n          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {\n            return result;\n          }\n          if (value === null) {\n            return [...result, [encode(key, options), '[', index, ']'].join('')];\n          }\n          return [...result, [encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')];\n        };\n      }\n    case 'bracket':\n      {\n        return key => (result, value) => {\n          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {\n            return result;\n          }\n          if (value === null) {\n            return [...result, [encode(key, options), '[]'].join('')];\n          }\n          return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];\n        };\n      }\n    case 'colon-list-separator':\n      {\n        return key => (result, value) => {\n          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {\n            return result;\n          }\n          if (value === null) {\n            return [...result, [encode(key, options), ':list='].join('')];\n          }\n          return [...result, [encode(key, options), ':list=', encode(value, options)].join('')];\n        };\n      }\n    case 'comma':\n    case 'separator':\n    case 'bracket-separator':\n      {\n        const keyValueSep = options.arrayFormat === 'bracket-separator' ? '[]=' : '=';\n        return key => (result, value) => {\n          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {\n            return result;\n          }\n\n          // Translate null to an empty string so that it doesn't serialize as 'null'\n          value = value === null ? '' : value;\n          if (result.length === 0) {\n            return [[encode(key, options), keyValueSep, encode(value, options)].join('')];\n          }\n          return [[result, encode(value, options)].join(options.arrayFormatSeparator)];\n        };\n      }\n    default:\n      {\n        return key => (result, value) => {\n          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {\n            return result;\n          }\n          if (value === null) {\n            return [...result, encode(key, options)];\n          }\n          return [...result, [encode(key, options), '=', encode(value, options)].join('')];\n        };\n      }\n  }\n}\nfunction parserForArrayFormat(options) {\n  let result;\n  switch (options.arrayFormat) {\n    case 'index':\n      {\n        return (key, value, accumulator) => {\n          result = /\\[(\\d*)]$/.exec(key);\n          key = key.replace(/\\[\\d*]$/, '');\n          if (!result) {\n            accumulator[key] = value;\n            return;\n          }\n          if (accumulator[key] === undefined) {\n            accumulator[key] = {};\n          }\n          accumulator[key][result[1]] = value;\n        };\n      }\n    case 'bracket':\n      {\n        return (key, value, accumulator) => {\n          result = /(\\[])$/.exec(key);\n          key = key.replace(/\\[]$/, '');\n          if (!result) {\n            accumulator[key] = value;\n            return;\n          }\n          if (accumulator[key] === undefined) {\n            accumulator[key] = [value];\n            return;\n          }\n          accumulator[key] = [...accumulator[key], value];\n        };\n      }\n    case 'colon-list-separator':\n      {\n        return (key, value, accumulator) => {\n          result = /(:list)$/.exec(key);\n          key = key.replace(/:list$/, '');\n          if (!result) {\n            accumulator[key] = value;\n            return;\n          }\n          if (accumulator[key] === undefined) {\n            accumulator[key] = [value];\n            return;\n          }\n          accumulator[key] = [...accumulator[key], value];\n        };\n      }\n    case 'comma':\n    case 'separator':\n      {\n        return (key, value, accumulator) => {\n          const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);\n          const isEncodedArray = typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator);\n          value = isEncodedArray ? decode(value, options) : value;\n          const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);\n          accumulator[key] = newValue;\n        };\n      }\n    case 'bracket-separator':\n      {\n        return (key, value, accumulator) => {\n          const isArray = /(\\[])$/.test(key);\n          key = key.replace(/\\[]$/, '');\n          if (!isArray) {\n            accumulator[key] = value ? decode(value, options) : value;\n            return;\n          }\n          const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map(item => decode(item, options));\n          if (accumulator[key] === undefined) {\n            accumulator[key] = arrayValue;\n            return;\n          }\n          accumulator[key] = [...accumulator[key], ...arrayValue];\n        };\n      }\n    default:\n      {\n        return (key, value, accumulator) => {\n          if (accumulator[key] === undefined) {\n            accumulator[key] = value;\n            return;\n          }\n          accumulator[key] = [...[accumulator[key]].flat(), value];\n        };\n      }\n  }\n}\nfunction validateArrayFormatSeparator(value) {\n  if (typeof value !== 'string' || value.length !== 1) {\n    throw new TypeError('arrayFormatSeparator must be single character string');\n  }\n}\nfunction encode(value, options) {\n  if (options.encode) {\n    return options.strict ? strictUriEncode(value) : encodeURIComponent(value);\n  }\n  return value;\n}\nfunction decode(value, options) {\n  if (options.decode) {\n    return decodeComponent(value);\n  }\n  return value;\n}\nfunction keysSorter(input) {\n  if (Array.isArray(input)) {\n    return input.sort();\n  }\n  if (typeof input === 'object') {\n    return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map(key => input[key]);\n  }\n  return input;\n}\nfunction removeHash(input) {\n  const hashStart = input.indexOf('#');\n  if (hashStart !== -1) {\n    input = input.slice(0, hashStart);\n  }\n  return input;\n}\nfunction getHash(url) {\n  let hash = '';\n  const hashStart = url.indexOf('#');\n  if (hashStart !== -1) {\n    hash = url.slice(hashStart);\n  }\n  return hash;\n}\nfunction parseValue(value, options) {\n  if (options.parseNumbers && !Number.isNaN(Number(value)) && typeof value === 'string' && value.trim() !== '') {\n    value = Number(value);\n  } else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {\n    value = value.toLowerCase() === 'true';\n  }\n  return value;\n}\nexport function extract(input) {\n  input = removeHash(input);\n  const queryStart = input.indexOf('?');\n  if (queryStart === -1) {\n    return '';\n  }\n  return input.slice(queryStart + 1);\n}\nexport function parse(query, options) {\n  options = {\n    decode: true,\n    sort: true,\n    arrayFormat: 'none',\n    arrayFormatSeparator: ',',\n    parseNumbers: false,\n    parseBooleans: false,\n    ...options\n  };\n  validateArrayFormatSeparator(options.arrayFormatSeparator);\n  const formatter = parserForArrayFormat(options);\n\n  // Create an object with no prototype\n  const returnValue = Object.create(null);\n  if (typeof query !== 'string') {\n    return returnValue;\n  }\n  query = query.trim().replace(/^[?#&]/, '');\n  if (!query) {\n    return returnValue;\n  }\n  for (const parameter of query.split('&')) {\n    if (parameter === '') {\n      continue;\n    }\n    const parameter_ = options.decode ? parameter.replace(/\\+/g, ' ') : parameter;\n    let [key, value] = splitOnFirst(parameter_, '=');\n    if (key === undefined) {\n      key = parameter_;\n    }\n\n    // Missing `=` should be `null`:\n    // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n    value = value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options);\n    formatter(decode(key, options), value, returnValue);\n  }\n  for (const [key, value] of Object.entries(returnValue)) {\n    if (typeof value === 'object' && value !== null) {\n      for (const [key2, value2] of Object.entries(value)) {\n        value[key2] = parseValue(value2, options);\n      }\n    } else {\n      returnValue[key] = parseValue(value, options);\n    }\n  }\n  if (options.sort === false) {\n    return returnValue;\n  }\n\n  // TODO: Remove the use of `reduce`.\n  // eslint-disable-next-line unicorn/no-array-reduce\n  return (options.sort === true ? Object.keys(returnValue).sort() : Object.keys(returnValue).sort(options.sort)).reduce((result, key) => {\n    const value = returnValue[key];\n    if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {\n      // Sort object keys, not values\n      result[key] = keysSorter(value);\n    } else {\n      result[key] = value;\n    }\n    return result;\n  }, Object.create(null));\n}\nexport function stringify(object, options) {\n  if (!object) {\n    return '';\n  }\n  options = {\n    encode: true,\n    strict: true,\n    arrayFormat: 'none',\n    arrayFormatSeparator: ',',\n    ...options\n  };\n  validateArrayFormatSeparator(options.arrayFormatSeparator);\n  const shouldFilter = key => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === '';\n  const formatter = encoderForArrayFormat(options);\n  const objectCopy = {};\n  for (const [key, value] of Object.entries(object)) {\n    if (!shouldFilter(key)) {\n      objectCopy[key] = value;\n    }\n  }\n  const keys = Object.keys(objectCopy);\n  if (options.sort !== false) {\n    keys.sort(options.sort);\n  }\n  return keys.map(key => {\n    const value = object[key];\n    if (value === undefined) {\n      return '';\n    }\n    if (value === null) {\n      return encode(key, options);\n    }\n    if (Array.isArray(value)) {\n      if (value.length === 0 && options.arrayFormat === 'bracket-separator') {\n        return encode(key, options) + '[]';\n      }\n      return value.reduce(formatter(key), []).join('&');\n    }\n    return encode(key, options) + '=' + encode(value, options);\n  }).filter(x => x.length > 0).join('&');\n}\nexport function parseUrl(url, options) {\n  var _url_$split$, _url_, _url_$split;\n  options = {\n    decode: true,\n    ...options\n  };\n  let [url_, hash] = splitOnFirst(url, '#');\n  if (url_ === undefined) {\n    url_ = url;\n  }\n  return {\n    url: (_url_$split$ = (_url_ = url_) === null || _url_ === void 0 ? void 0 : (_url_$split = _url_.split('?')) === null || _url_$split === void 0 ? void 0 : _url_$split[0]) !== null && _url_$split$ !== void 0 ? _url_$split$ : '',\n    query: parse(extract(url), options),\n    ...(options && options.parseFragmentIdentifier && hash ? {\n      fragmentIdentifier: decode(hash, options)\n    } : {})\n  };\n}\nexport function stringifyUrl(object, options) {\n  options = {\n    encode: true,\n    strict: true,\n    [encodeFragmentIdentifier]: true,\n    ...options\n  };\n  const url = removeHash(object.url).split('?')[0] || '';\n  const queryFromUrl = extract(object.url);\n  const query = {\n    ...parse(queryFromUrl, {\n      sort: false\n    }),\n    ...object.query\n  };\n  let queryString = stringify(query, options);\n  if (queryString) {\n    queryString = \"?\".concat(queryString);\n  }\n  let hash = getHash(object.url);\n  if (object.fragmentIdentifier) {\n    const urlObjectForFragmentEncode = new URL(url);\n    urlObjectForFragmentEncode.hash = object.fragmentIdentifier;\n    hash = options[encodeFragmentIdentifier] ? urlObjectForFragmentEncode.hash : \"#\".concat(object.fragmentIdentifier);\n  }\n  return \"\".concat(url).concat(queryString).concat(hash);\n}\nexport function pick(input, filter, options) {\n  options = {\n    parseFragmentIdentifier: true,\n    [encodeFragmentIdentifier]: false,\n    ...options\n  };\n  const {\n    url,\n    query,\n    fragmentIdentifier\n  } = parseUrl(input, options);\n  return stringifyUrl({\n    url,\n    query: includeKeys(query, filter),\n    fragmentIdentifier\n  }, options);\n}\nexport function exclude(input, filter, options) {\n  const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);\n  return pick(input, exclusionFilter, options);\n}","import * as queryString from './base.js';\nexport default queryString;","import * as React from 'react';\nimport { useEffect } from 'react';\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nvar observerMap = new Map();\nvar RootIds = new WeakMap();\nvar rootId = 0;\nvar unsupportedValue = undefined;\n/**\r\n * What should be the default behavior if the IntersectionObserver is unsupported?\r\n * Ideally the polyfill has been loaded, you can have the following happen:\r\n * - `undefined`: Throw an error\r\n * - `true` or `false`: Set the `inView` value to this regardless of intersection state\r\n * **/\n\nfunction defaultFallbackInView(inView) {\n  unsupportedValue = inView;\n}\n/**\r\n * Generate a unique ID for the root element\r\n * @param root\r\n */\n\nfunction getRootId(root) {\n  if (!root) return '0';\n  if (RootIds.has(root)) return RootIds.get(root);\n  rootId += 1;\n  RootIds.set(root, rootId.toString());\n  return RootIds.get(root);\n}\n/**\r\n * Convert the options to a string Id, based on the values.\r\n * Ensures we can reuse the same observer when observing elements with the same options.\r\n * @param options\r\n */\n\nfunction optionsToId(options) {\n  return Object.keys(options).sort().filter(function (key) {\n    return options[key] !== undefined;\n  }).map(function (key) {\n    return key + \"_\" + (key === 'root' ? getRootId(options.root) : options[key]);\n  }).toString();\n}\nfunction createObserver(options) {\n  // Create a unique ID for this observer instance, based on the root, root margin and threshold.\n  var id = optionsToId(options);\n  var instance = observerMap.get(id);\n  if (!instance) {\n    // Create a map of elements this observer is going to observe. Each element has a list of callbacks that should be triggered, once it comes into view.\n    var elements = new Map();\n    var thresholds;\n    var observer = new IntersectionObserver(function (entries) {\n      entries.forEach(function (entry) {\n        var _elements$get;\n\n        // While it would be nice if you could just look at isIntersecting to determine if the component is inside the viewport, browsers can't agree on how to use it.\n        // -Firefox ignores `threshold` when considering `isIntersecting`, so it will never be false again if `threshold` is > 0\n        var inView = entry.isIntersecting && thresholds.some(function (threshold) {\n          return entry.intersectionRatio >= threshold;\n        }); // @ts-ignore support IntersectionObserver v2\n\n        if (options.trackVisibility && typeof entry.isVisible === 'undefined') {\n          // The browser doesn't support Intersection Observer v2, falling back to v1 behavior.\n          // @ts-ignore\n          entry.isVisible = inView;\n        }\n        (_elements$get = elements.get(entry.target)) == null ? void 0 : _elements$get.forEach(function (callback) {\n          callback(inView, entry);\n        });\n      });\n    }, options); // Ensure we have a valid thresholds array. If not, use the threshold from the options\n\n    thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);\n    instance = {\n      id: id,\n      observer: observer,\n      elements: elements\n    };\n    observerMap.set(id, instance);\n  }\n  return instance;\n}\n/**\r\n * @param element - DOM Element to observe\r\n * @param callback - Callback function to trigger when intersection status changes\r\n * @param options - Intersection Observer options\r\n * @param fallbackInView - Fallback inView value.\r\n * @return Function - Cleanup function that should be triggered to unregister the observer\r\n */\n\nfunction observe(element, callback, options, fallbackInView) {\n  if (options === void 0) {\n    options = {};\n  }\n  if (fallbackInView === void 0) {\n    fallbackInView = unsupportedValue;\n  }\n  if (typeof window.IntersectionObserver === 'undefined' && fallbackInView !== undefined) {\n    var bounds = element.getBoundingClientRect();\n    callback(fallbackInView, {\n      isIntersecting: fallbackInView,\n      target: element,\n      intersectionRatio: typeof options.threshold === 'number' ? options.threshold : 0,\n      time: 0,\n      boundingClientRect: bounds,\n      intersectionRect: bounds,\n      rootBounds: bounds\n    });\n    return function () {// Nothing to cleanup\n    };\n  } // An observer with the same options can be reused, so lets use this fact\n\n  var _createObserver = createObserver(options),\n    id = _createObserver.id,\n    observer = _createObserver.observer,\n    elements = _createObserver.elements; // Register the callback listener for this element\n\n  var callbacks = elements.get(element) || [];\n  if (!elements.has(element)) {\n    elements.set(element, callbacks);\n  }\n  callbacks.push(callback);\n  observer.observe(element);\n  return function unobserve() {\n    // Remove the callback from the callback list\n    callbacks.splice(callbacks.indexOf(callback), 1);\n    if (callbacks.length === 0) {\n      // No more callback exists for element, so destroy it\n      elements[\"delete\"](element);\n      observer.unobserve(element);\n    }\n    if (elements.size === 0) {\n      // No more elements are being observer by this instance, so destroy it\n      observer.disconnect();\n      observerMap[\"delete\"](id);\n    }\n  };\n}\nvar _excluded = [\"children\", \"as\", \"triggerOnce\", \"threshold\", \"root\", \"rootMargin\", \"onChange\", \"skip\", \"trackVisibility\", \"delay\", \"initialInView\", \"fallbackInView\"];\nfunction isPlainChildren(props) {\n  return typeof props.children !== 'function';\n}\n/**\r\n ## Render props\r\n\n To use the `<InView>` component, you pass it a function. It will be called\r\n whenever the state changes, with the new value of `inView`. In addition to the\r\n `inView` prop, children also receive a `ref` that should be set on the\r\n containing DOM element. This is the element that the IntersectionObserver will\r\n monitor.\r\n\n If you need it, you can also access the\r\n [`IntersectionObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry)\r\n on `entry`, giving you access to all the details about the current intersection\r\n state.\r\n\n ```jsx\r\n import { InView } from 'react-intersection-observer';\r\n\n const Component = () => (\r\n <InView>\r\n {({ inView, ref, entry }) => (\r\n      <div ref={ref}>\r\n        <h2>{`Header inside viewport ${inView}.`}</h2>\r\n      </div>\r\n    )}\r\n </InView>\r\n );\r\n\n export default Component;\r\n ```\r\n\n ## Plain children\r\n\n You can pass any element to the `<InView />`, and it will handle creating the\r\n wrapping DOM element. Add a handler to the `onChange` method, and control the\r\n state in your own component. Any extra props you add to `<InView>` will be\r\n passed to the HTML element, allowing you set the `className`, `style`, etc.\r\n\n ```jsx\r\n import { InView } from 'react-intersection-observer';\r\n\n const Component = () => (\r\n <InView as=\"div\" onChange={(inView, entry) => console.log('Inview:', inView)}>\r\n <h2>Plain children are always rendered. Use onChange to monitor state.</h2>\r\n </InView>\r\n );\r\n\n export default Component;\r\n ```\r\n */\n\nvar InView = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(InView, _React$Component);\n  function InView(props) {\n    var _this;\n    _this = _React$Component.call(this, props) || this;\n    _this.node = null;\n    _this._unobserveCb = null;\n    _this.handleNode = function (node) {\n      if (_this.node) {\n        // Clear the old observer, before we start observing a new element\n        _this.unobserve();\n        if (!node && !_this.props.triggerOnce && !_this.props.skip) {\n          // Reset the state if we get a new node, and we aren't ignoring updates\n          _this.setState({\n            inView: !!_this.props.initialInView,\n            entry: undefined\n          });\n        }\n      }\n      _this.node = node ? node : null;\n      _this.observeNode();\n    };\n    _this.handleChange = function (inView, entry) {\n      if (inView && _this.props.triggerOnce) {\n        // If `triggerOnce` is true, we should stop observing the element.\n        _this.unobserve();\n      }\n      if (!isPlainChildren(_this.props)) {\n        // Store the current State, so we can pass it to the children in the next render update\n        // There's no reason to update the state for plain children, since it's not used in the rendering.\n        _this.setState({\n          inView: inView,\n          entry: entry\n        });\n      }\n      if (_this.props.onChange) {\n        // If the user is actively listening for onChange, always trigger it\n        _this.props.onChange(inView, entry);\n      }\n    };\n    _this.state = {\n      inView: !!props.initialInView,\n      entry: undefined\n    };\n    return _this;\n  }\n  var _proto = InView.prototype;\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    // If a IntersectionObserver option changed, reinit the observer\n    if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold || prevProps.skip !== this.props.skip || prevProps.trackVisibility !== this.props.trackVisibility || prevProps.delay !== this.props.delay) {\n      this.unobserve();\n      this.observeNode();\n    }\n  };\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.unobserve();\n    this.node = null;\n  };\n  _proto.observeNode = function observeNode() {\n    if (!this.node || this.props.skip) return;\n    var _this$props = this.props,\n      threshold = _this$props.threshold,\n      root = _this$props.root,\n      rootMargin = _this$props.rootMargin,\n      trackVisibility = _this$props.trackVisibility,\n      delay = _this$props.delay,\n      fallbackInView = _this$props.fallbackInView;\n    this._unobserveCb = observe(this.node, this.handleChange, {\n      threshold: threshold,\n      root: root,\n      rootMargin: rootMargin,\n      // @ts-ignore\n      trackVisibility: trackVisibility,\n      // @ts-ignore\n      delay: delay\n    }, fallbackInView);\n  };\n  _proto.unobserve = function unobserve() {\n    if (this._unobserveCb) {\n      this._unobserveCb();\n      this._unobserveCb = null;\n    }\n  };\n  _proto.render = function render() {\n    if (!isPlainChildren(this.props)) {\n      var _this$state = this.state,\n        inView = _this$state.inView,\n        entry = _this$state.entry;\n      return this.props.children({\n        inView: inView,\n        entry: entry,\n        ref: this.handleNode\n      });\n    }\n    var _this$props2 = this.props,\n      children = _this$props2.children,\n      as = _this$props2.as,\n      props = _objectWithoutPropertiesLoose(_this$props2, _excluded);\n    return /*#__PURE__*/React.createElement(as || 'div', _extends({\n      ref: this.handleNode\n    }, props), children);\n  };\n  return InView;\n}(React.Component);\nInView.displayName = 'InView';\nInView.defaultProps = {\n  threshold: 0,\n  triggerOnce: false,\n  initialInView: false\n};\n\n/**\r\n * React Hooks make it easy to monitor the `inView` state of your components. Call\r\n * the `useInView` hook with the (optional) [options](#options) you need. It will\r\n * return an array containing a `ref`, the `inView` status and the current\r\n * [`entry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry).\r\n * Assign the `ref` to the DOM element you want to monitor, and the hook will\r\n * report the status.\r\n *\r\n * @example\r\n * ```jsx\r\n * import React from 'react';\r\n * import { useInView } from 'react-intersection-observer';\r\n *\r\n * const Component = () => {\r\n *   const { ref, inView, entry } = useInView({\r\n *       threshold: 0,\r\n *   });\r\n *\r\n *   return (\r\n *     <div ref={ref}>\r\n *       <h2>{`Header inside viewport ${inView}.`}</h2>\r\n *     </div>\r\n *   );\r\n * };\r\n * ```\r\n */\n\nfunction useInView(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    threshold = _ref.threshold,\n    delay = _ref.delay,\n    trackVisibility = _ref.trackVisibility,\n    rootMargin = _ref.rootMargin,\n    root = _ref.root,\n    triggerOnce = _ref.triggerOnce,\n    skip = _ref.skip,\n    initialInView = _ref.initialInView,\n    fallbackInView = _ref.fallbackInView;\n  var unobserve = React.useRef();\n  var _React$useState = React.useState({\n      inView: !!initialInView\n    }),\n    state = _React$useState[0],\n    setState = _React$useState[1];\n  var setRef = React.useCallback(function (node) {\n    if (unobserve.current !== undefined) {\n      unobserve.current();\n      unobserve.current = undefined;\n    } // Skip creating the observer\n\n    if (skip) return;\n    if (node) {\n      unobserve.current = observe(node, function (inView, entry) {\n        setState({\n          inView: inView,\n          entry: entry\n        });\n        if (entry.isIntersecting && triggerOnce && unobserve.current) {\n          // If it should only trigger once, unobserve the element after it's inView\n          unobserve.current();\n          unobserve.current = undefined;\n        }\n      }, {\n        root: root,\n        rootMargin: rootMargin,\n        threshold: threshold,\n        // @ts-ignore\n        trackVisibility: trackVisibility,\n        // @ts-ignore\n        delay: delay\n      }, fallbackInView);\n    }\n  },\n  // We break the rule here, because we aren't including the actual `threshold` variable\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [\n  // If the threshold is an array, convert it to a string so it won't change between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  Array.isArray(threshold) ? threshold.toString() : threshold, root, rootMargin, triggerOnce, skip, trackVisibility, fallbackInView, delay]);\n  /* eslint-disable-next-line */\n\n  useEffect(function () {\n    if (!unobserve.current && state.entry && !triggerOnce && !skip) {\n      // If we don't have a ref, then reset the state (unless the hook is set to only `triggerOnce` or `skip`)\n      // This ensures we correctly reflect the current state - If you aren't observing anything, then nothing is inView\n      setState({\n        inView: !!initialInView\n      });\n    }\n  });\n  var result = [setRef, state.inView, state.entry]; // Support object destructuring, by adding the specific values.\n\n  result.ref = result[0];\n  result.inView = result[1];\n  result.entry = result[2];\n  return result;\n}\nexport { InView, InView as default, defaultFallbackInView, observe, useInView };"],"sourceRoot":""}